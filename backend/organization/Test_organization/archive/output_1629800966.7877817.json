{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}, "tests": {"0": {"status": "ERROR", "message": "setup_test_company = [{'active': False, 'address1': '748 Tyler Islands\\nShannonfort, VA 63991', 'city': 'East William', 'country': 'Palesti...ress1': '4972 Morrison Trafficway Suite 254\\nEast Susan, MT 69856', 'city': 'Fieldsbury', 'country': 'Guatemala', ...}]\n\n    @pytest.fixture\n    def setup_company_info(setup_test_company):\n    \tgetCompanies=setup_test_company\n    \tcompanyinfo=[]\n    \tfor company in getCompanies:\n>   \t\tgetCompany=Company.objects.get(company=company[\"name\"])\n\n..\\..\\conftest.py:564: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:424: in get\n    clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:941: in filter\n    return self._filter_or_exclude(False, args, kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:961: in _filter_or_exclude\n    clone._filter_or_exclude_inplace(negate, args, kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:968: in _filter_or_exclude_inplace\n    self._query.add_q(Q(*args, **kwargs))\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\sql\\query.py:1391: in add_q\n    clause, _ = self._add_q(q_object, self.used_aliases)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\sql\\query.py:1413: in _add_q\n    split_subq=split_subq, check_filterable=check_filterable,\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\sql\\query.py:1284: in build_filter\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\sql\\query.py:1110: in solve_lookup_type\n    _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <django.db.models.sql.query.Query object at 0x000001E15D281248>, names = ['company'], opts = <Options for Company>\nallow_many = True, fail_on_missing = False\n\n    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n        \"\"\"\n        Walk the list of names and turns them into PathInfo tuples. A single\n        name in 'names' can generate multiple PathInfos (m2m, for example).\n    \n        'names' is the path of names to travel, 'opts' is the model Options we\n        start the name resolving from, 'allow_many' is as for setup_joins().\n        If fail_on_missing is set to True, then a name that can't be resolved\n        will generate a FieldError.\n    \n        Return a list of PathInfo tuples. In addition return the final field\n        (the last used join field) and target (which is a field guaranteed to\n        contain the same value as the final field). Finally, return those names\n        that weren't found (which are likely transforms and the final lookup).\n        \"\"\"\n        path, names_with_path = [], []\n        for pos, name in enumerate(names):\n            cur_names_with_path = (name, [])\n            if name == 'pk':\n                name = opts.pk.name\n    \n            field = None\n            filtered_relation = None\n            try:\n                field = opts.get_field(name)\n            except FieldDoesNotExist:\n                if name in self.annotation_select:\n                    field = self.annotation_select[name].output_field\n                elif name in self._filtered_relations and pos == 0:\n                    filtered_relation = self._filtered_relations[name]\n                    if LOOKUP_SEP in filtered_relation.relation_name:\n                        parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                        filtered_relation_path, field, _, _ = self.names_to_path(\n                            parts, opts, allow_many, fail_on_missing,\n                        )\n                        path.extend(filtered_relation_path[:-1])\n                    else:\n                        field = opts.get_field(filtered_relation.relation_name)\n            if field is not None:\n                # Fields that contain one-to-many relations with a generic\n                # model (like a GenericForeignKey) cannot generate reverse\n                # relations and therefore cannot be used for reverse querying.\n                if field.is_relation and not field.related_model:\n                    raise FieldError(\n                        \"Field %r does not generate an automatic reverse \"\n                        \"relation and therefore cannot be used for reverse \"\n                        \"querying. If it is a GenericForeignKey, consider \"\n                        \"adding a GenericRelation.\" % name\n                    )\n                try:\n                    model = field.model._meta.concrete_model\n                except AttributeError:\n                    # QuerySet.annotate() may introduce fields that aren't\n                    # attached to a model.\n                    model = None\n            else:\n                # We didn't find the current field, so move position back\n                # one step.\n                pos -= 1\n                if pos == -1 or fail_on_missing:\n                    available = sorted([\n                        *get_field_names_from_opts(opts),\n                        *self.annotation_select,\n                        *self._filtered_relations,\n                    ])\n                    raise FieldError(\"Cannot resolve keyword '%s' into field. \"\n>                                    \"Choices are: %s\" % (name, \", \".join(available)))\nE                   django.core.exceptions.FieldError: Cannot resolve keyword 'company' into field. Choices are: active, address1, address2, city, companyinfo, country, created_at, created_by, created_by_id, id, name, partner_name, state, state_pin_code, updated_at, updated_by, updated_by_id, usercompanyrole\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\sql\\query.py:1538: FieldError\n", "test_name": "test_company_info", "rerun": "0"}}, "suite_name": "organization/Test_organization/test_models.py"}}}, "date": "August 24, 2021", "start_time": 1629800892.109377, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "1", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "1"}