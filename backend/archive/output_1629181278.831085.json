{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 16}, "tests": {"0": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_login_url", "rerun": "0"}, "1": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_reset_password_url", "rerun": "0"}, "2": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_update_password_url", "rerun": "0"}, "3": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_new_password_url", "rerun": "0"}, "4": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_logout_url", "rerun": "0"}, "5": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_check_token_url", "rerun": "0"}, "6": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_download_file_url", "rerun": "0"}, "7": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_create_role_url", "rerun": "0"}, "8": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_get_role_url", "rerun": "0"}, "9": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_register_user_url", "rerun": "0"}, "10": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_register_worker_url", "rerun": "0"}, "11": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_register_access_url", "rerun": "0"}, "12": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_edit_user_url", "rerun": "0"}, "13": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_edit_user_byid_url", "rerun": "0"}, "14": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_deactivate_user_url", "rerun": "0"}, "15": {"status": "ERROR", "message": "setup_superusers = None\n\n    @pytest.fixture(autouse=True)\n    def setup_company(setup_superusers):\n    \tcompany ={\"name\": \"Administrator\",\n    \t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompany[\"created_by\"] = Users.objects.filter(id=company[\"created_by\"])[0]\n    \tcompany[\"updated_by\"] = Users.objects.filter(id=company[\"updated_by\"])[0]\n    \tgetCompany = Company.objects.create(**company)\n    \tcompanyRole={\"user\": 1,\n    \t\t\t\t\"company\": 1,\"role\": 1,\n    \t\t\t\t\"created_by\": 1,\"updated_by\": 1,}\n    \tcompanyRole[\"created_by\"] = Users.objects.filter(id=companyRole[\"created_by\"])[0]\n    \tcompanyRole[\"updated_by\"] = Users.objects.filter(id=companyRole[\"updated_by\"])[0]\n    \tcompanyRole[\"user\"] = Users.objects.filter(id=companyRole[\"user\"])[0]\n    \tcompanyRole[\"company\"] = Company.objects.filter(id=companyRole[\"company\"])[0]\n>   \tcompanyRole[\"role\"] = Roles.objects.filter(id=companyRole[\"role\"])[0]\n\nusermanagement\\Test_Usermanagement\\conftest.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <QuerySet []>, k = 0\n\n    def __getitem__(self, k):\n        \"\"\"Retrieve an item or slice from the set of results.\"\"\"\n        if not isinstance(k, (int, slice)):\n            raise TypeError(\n                'QuerySet indices must be integers or slices, not %s.'\n                % type(k).__name__\n            )\n        assert ((not isinstance(k, slice) and (k >= 0)) or\n                (isinstance(k, slice) and (k.start is None or k.start >= 0) and\n                 (k.stop is None or k.stop >= 0))), \\\n            \"Negative indexing is not supported.\"\n    \n        if self._result_cache is not None:\n            return self._result_cache[k]\n    \n        if isinstance(k, slice):\n            qs = self._chain()\n            if k.start is not None:\n                start = int(k.start)\n            else:\n                start = None\n            if k.stop is not None:\n                stop = int(k.stop)\n            else:\n                stop = None\n            qs.query.set_limits(start, stop)\n            return list(qs)[::k.step] if k.step else qs\n    \n        qs = self._chain()\n        qs.query.set_limits(k, k + 1)\n        qs._fetch_all()\n>       return qs._result_cache[0]\nE       IndexError: list index out of range\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:318: IndexError\n", "test_name": "test_list_user_byemail_url", "rerun": "0"}}, "suite_name": "usermanagement/Test_Usermanagement/test_urls.py"}}}, "date": "August 17, 2021", "start_time": 1629180934.668699, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "16", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "16"}