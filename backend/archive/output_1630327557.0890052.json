{"content": {"suites": {"0": {"status": {"total_pass": 4, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 1}, "tests": {"0": {"status": "PASS", "message": "", "test_name": "test_all_project_info", "rerun": "0"}, "1": {"status": "PASS", "message": "", "test_name": "test_project_info_models", "rerun": "0"}, "2": {"status": "PASS", "message": "", "test_name": "test_project_users_models", "rerun": "0"}, "3": {"status": "PASS", "message": "", "test_name": "test_file_upload", "rerun": "0"}, "4": {"status": "ERROR", "message": "setup_projectusers = []\n\n    @pytest.fixture\n    def setup_project_activitylog(setup_projectusers):\n    \n    \tactivity_logs=[]\n    \tfor projectuser in ProjectUsers.objects.all():\n    \t\tactivity={\"project_user\":projectuser,\"timestamp\":fake.date()\n    \t\t\t,\"activity\":fake.text(max_nb_chars=100),\"ip_address\":fake.ipv4(),\"created_by_id\":1}\n>   \t\tgetActivityLogs=ActivityLog.objects.create(**activity)\n\nconftest.py:802: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = (), kwargs = {'created_by_id': 1}\ncls = <class 'project.models.ActivityLogs'>, opts = <Options for ActivityLogs>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>, fields_iter = <tuple_iterator object at 0x000001B6EB0C6F08>, val = '170.22.65.214'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False\nrel_obj = <ProjectUsers: ProjectUsers object (1)>, property_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'created_by_id'\n\n..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activity_logs", "rerun": "0"}}, "suite_name": "project/Test_project/test_models.py"}}}, "date": "August 30, 2021", "start_time": 1630327524.2898614, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "4", "fail": "0", "skip": "0", "error": "1", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "5"}