{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 2}, "tests": {"0": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': 'e171f7cb-a', ...}, {'active': True,...0d-1', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': 'e58dad5c-6', ...}, ...]\n\n    @pytest.fixture\n    def setup_register_access(setup_saved_user):\n    \taccess_data=[]\n    \taccess={\"company_name\":\"Amazon\",\"name\":\"Nitin\",\"email\":'Nitin@momenttext.com'\n                ,\"phone_number\":''.join((random.choice(string.digits) for i in range(10)))\n    \t\t\t,\"skill_sets\":[\"java\",\"c++\",\"jquery\"]\n    \t\t\t,\"created_at\":fake.date_time(tzinfo=timezone.utc)\n       \t\t\t,\"updated_at\":fake.date_time(tzinfo=timezone.utc)}\n    \tgetWorker=AccessRequest.objects.create(**access)\n    \n    \tfor obj in range(5):\n    \t\taccess={\"name\":fake.name(),\"company_name\":fake.company()\n    \t\t\t\t,\"email\":fake.email(domain='momenttext.com'),\"active\":False\n    \t\t\t\t,\"phone_no\":''.join((random.choice(string.digits) for i in range(10)))\n    \t\t\t\t,\"skill_sets\":[\"java\",\"c++\",\"jquery\"]\n    \t\t\t\t,\"created_at\":fake.date_time(tzinfo=timezone.utc)\n    \t\t\t\t,\"updated_at\":fake.date_time(tzinfo=timezone.utc)}\n    \t\taccess_data.append(access)\n>   \t\tgetWorker=AccessRequest.objects.create(**access)\n\n..\\..\\conftest.py:271: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <AccessRequest: Michael Foster>, args = (), kwargs = {'phone_no': '0332389349'}\ncls = <class 'usermanagement.models.AccessRequest'>, opts = <Options for AccessRequest>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x00000243DCF53248>, val = datetime.datetime(1990, 10, 31, 16, 50, 9, tzinfo=<UTC>)\nfield = <django.db.models.fields.DateTimeField: updated_at>, is_related_object = False, property_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: AccessRequest() got an unexpected keyword argument 'phone_no'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_worker", "rerun": "0"}, "1": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': 'f176921d-6', ...}, {'active': True,...a1-2', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '3d49bde4-d', ...}, ...]\n\n    @pytest.fixture\n    def setup_register_access(setup_saved_user):\n    \taccess_data=[]\n    \taccess={\"company_name\":\"Amazon\",\"name\":\"Nitin\",\"email\":'Nitin@momenttext.com'\n                ,\"phone_number\":''.join((random.choice(string.digits) for i in range(10)))\n    \t\t\t,\"skill_sets\":[\"java\",\"c++\",\"jquery\"]\n    \t\t\t,\"created_at\":fake.date_time(tzinfo=timezone.utc)\n       \t\t\t,\"updated_at\":fake.date_time(tzinfo=timezone.utc)}\n    \tgetWorker=AccessRequest.objects.create(**access)\n    \n    \tfor obj in range(5):\n    \t\taccess={\"name\":fake.name(),\"company_name\":fake.company()\n    \t\t\t\t,\"email\":fake.email(domain='momenttext.com'),\"active\":False\n    \t\t\t\t,\"phone_no\":''.join((random.choice(string.digits) for i in range(10)))\n    \t\t\t\t,\"skill_sets\":[\"java\",\"c++\",\"jquery\"]\n    \t\t\t\t,\"created_at\":fake.date_time(tzinfo=timezone.utc)\n    \t\t\t\t,\"updated_at\":fake.date_time(tzinfo=timezone.utc)}\n    \t\taccess_data.append(access)\n>   \t\tgetWorker=AccessRequest.objects.create(**access)\n\n..\\..\\conftest.py:271: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <AccessRequest: Austin Navarro>, args = (), kwargs = {'phone_no': '3004483594'}\ncls = <class 'usermanagement.models.AccessRequest'>, opts = <Options for AccessRequest>\n_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x00000243DCD95208>, val = datetime.datetime(1996, 10, 22, 10, 0, tzinfo=<UTC>)\nfield = <django.db.models.fields.DateTimeField: updated_at>, is_related_object = False, property_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: AccessRequest() got an unexpected keyword argument 'phone_no'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_worker_all", "rerun": "0"}}, "suite_name": "usermanagement/Test_usermanagement/test_models.py"}}}, "date": "August 18, 2021", "start_time": 1629282263.988089, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "2", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "2"}