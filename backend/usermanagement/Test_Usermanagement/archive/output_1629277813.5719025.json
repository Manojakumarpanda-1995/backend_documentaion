{"content": {"suites": {"0": {"status": {"total_pass": 0, "total_skip": 0, "total_xpass": 0, "total_xfail": 0, "total_rerun": 0, "total_fail": 0, "total_error": 8}, "tests": {"0": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': '7d03d87f-6', ...}, {'active': True,...84-1', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '41aa1d9c-d', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 3, 10727)}, cls = <class 'usermanagement.models.ActivityLogs'>\nopts = <Options for ActivityLogs>, _setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000001EE79C68C08>, val = '93.156.58.237'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser1@kpmg.com-True-False]", "rerun": "0"}, "1": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': '5afbd018-d', ...}, {'active': True,...64-4', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '8207fbde-0', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 3, 343878)}\ncls = <class 'usermanagement.models.ActivityLogs'>, opts = <Options for ActivityLogs>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>, fields_iter = <tuple_iterator object at 0x000001EE79B90148>, val = '204.104.115.164'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser2@kpmg.com-True-False]", "rerun": "0"}, "2": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': 'e20b36eb-a', ...}, {'active': True,...d0-a', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '3f14272f-8', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 3, 507039)}\ncls = <class 'usermanagement.models.ActivityLogs'>, opts = <Options for ActivityLogs>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>, fields_iter = <tuple_iterator object at 0x000001EE7999B908>, val = '102.95.81.122'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser3@kpmg.com-True-False]", "rerun": "0"}, "3": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': '2eafe336-b', ...}, {'active': True,...dc-f', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '1a3e9cfb-7', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 3, 671217)}\ncls = <class 'usermanagement.models.ActivityLogs'>, opts = <Options for ActivityLogs>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>, fields_iter = <tuple_iterator object at 0x000001EE797B5948>, val = '121.38.56.43'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser4@kpmg.com-False-True]", "rerun": "0"}, "4": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': 'bba9e246-7', ...}, {'active': True,...8c-d', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '544586b3-b', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 3, 872103)}\ncls = <class 'usermanagement.models.ActivityLogs'>, opts = <Options for ActivityLogs>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>, fields_iter = <tuple_iterator object at 0x000001EE799F0CC8>, val = '14.150.30.81'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser5@kpmg.com-False-True]", "rerun": "0"}, "5": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': 'ead2dd32-1', ...}, {'active': True,...a4-a', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '90fa71fa-7', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 4, 36638)}, cls = <class 'usermanagement.models.ActivityLogs'>\nopts = <Options for ActivityLogs>, _setattr = <built-in function setattr>, _DEFERRED = <Deferred field>\nfields_iter = <tuple_iterator object at 0x000001EE786FFCC8>, val = '213.122.0.238'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser6@kpmg.com-False-True]", "rerun": "0"}, "6": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': '70365052-7', ...}, {'active': True,...7c-1', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '8a3c90d5-c', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 4, 241511)}\ncls = <class 'usermanagement.models.ActivityLogs'>, opts = <Options for ActivityLogs>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>, fields_iter = <tuple_iterator object at 0x000001EE79AEFD08>, val = '209.23.188.46'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser7@kpmg.com-False-False]", "rerun": "0"}, "7": {"status": "ERROR", "message": "setup_saved_user = [{'active': True, 'email': 'testuser1@kpmg.com', 'first_name': 'test', 'hashkey': '890818ec-4', ...}, {'active': True,...14-5', ...}, {'active': False, 'email': 'testuser6@kpmg.com', 'first_name': 'test', 'hashkey': '521e17dd-1', ...}, ...]\n\n    @pytest.fixture\n    def setup_activitylogs(setup_saved_user):\n    \tusers=setup_saved_user\n    \n    \tfor x in range(len(users)):\n    \t\tgetUser=Users.objects.get(email__iexact=users[x][\"email\"])\n    \t\tactivity_logs={\"user\":getUser\n                    ,\"activity\":fake.text(max_nb_chars=70)\n                    ,\"ip_address\":fake.ipv4()\n    \t\t\t\t,\"time_stamp\":datetime.now()\n                    }\n    \n>   \t\tgetActivityLogs=ActivityLogs.objects.create(**activity_logs)\n\n..\\..\\conftest.py:226: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\manager.py:85: in manager_method\n    return getattr(self.get_queryset(), name)(*args, **kwargs)\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\query.py:451: in create\n    obj = self.model(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ActivityLogs: ActivityLogs object (None)>, args = ()\nkwargs = {'time_stamp': datetime.datetime(2021, 8, 18, 14, 39, 4, 406216)}\ncls = <class 'usermanagement.models.ActivityLogs'>, opts = <Options for ActivityLogs>, _setattr = <built-in function setattr>\n_DEFERRED = <Deferred field>, fields_iter = <tuple_iterator object at 0x000001EE79A4E608>, val = '54.204.134.148'\nfield = <django.db.models.fields.CharField: ip_address>, is_related_object = False, rel_obj = <Users: Users object (2)>\nproperty_names = frozenset({'pk'})\n\n    def __init__(self, *args, **kwargs):\n        # Alias some things as locals to avoid repeat global lookups\n        cls = self.__class__\n        opts = self._meta\n        _setattr = setattr\n        _DEFERRED = DEFERRED\n        if opts.abstract:\n            raise TypeError('Abstract models cannot be instantiated.')\n    \n        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    \n        # Set up the storage for instance state\n        self._state = ModelState()\n    \n        # There is a rather weird disparity here; if kwargs, it's set, then args\n        # overrides it. It should be one or the other; don't duplicate the work\n        # The reason for the kwargs check is that standard iterator passes in by\n        # args, and instantiation for iteration is 33% faster.\n        if len(args) > len(opts.concrete_fields):\n            # Daft, but matches old exception sans the err msg.\n            raise IndexError(\"Number of args exceeds number of fields\")\n    \n        if not kwargs:\n            fields_iter = iter(opts.concrete_fields)\n            # The ordering of the zip calls matter - zip throws StopIteration\n            # when an iter throws it. So if the first iter throws it, the second\n            # is *not* consumed. We rely on this, so don't change the order\n            # without changing the logic.\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n        else:\n            # Slower, kwargs-ready version.\n            fields_iter = iter(opts.fields)\n            for val, field in zip(args, fields_iter):\n                if val is _DEFERRED:\n                    continue\n                _setattr(self, field.attname, val)\n                kwargs.pop(field.name, None)\n    \n        # Now we're left with the unprocessed fields that *must* come from\n        # keywords, or default.\n    \n        for field in fields_iter:\n            is_related_object = False\n            # Virtual field\n            if field.attname not in kwargs and field.column is None:\n                continue\n            if kwargs:\n                if isinstance(field.remote_field, ForeignObjectRel):\n                    try:\n                        # Assume object instance was passed in.\n                        rel_obj = kwargs.pop(field.name)\n                        is_related_object = True\n                    except KeyError:\n                        try:\n                            # Object instance wasn't passed in -- must be an ID.\n                            val = kwargs.pop(field.attname)\n                        except KeyError:\n                            val = field.get_default()\n                else:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        # This is done with an exception rather than the\n                        # default argument on pop because we don't want\n                        # get_default() to be evaluated, and then not used.\n                        # Refs #12057.\n                        val = field.get_default()\n            else:\n                val = field.get_default()\n    \n            if is_related_object:\n                # If we are passed a related instance, set it using the\n                # field.name instead of field.attname (e.g. \"user\" instead of\n                # \"user_id\") so that the object gets properly cached (and type\n                # checked) by the RelatedObjectDescriptor.\n                if rel_obj is not _DEFERRED:\n                    _setattr(self, field.name, rel_obj)\n            else:\n                if val is not _DEFERRED:\n                    _setattr(self, field.attname, val)\n    \n        if kwargs:\n            property_names = opts._property_names\n            for prop in tuple(kwargs):\n                try:\n                    # Any remaining kwargs must correspond to properties or\n                    # virtual fields.\n                    if prop in property_names or opts.get_field(prop):\n                        if kwargs[prop] is not _DEFERRED:\n                            _setattr(self, prop, kwargs[prop])\n                        del kwargs[prop]\n                except (AttributeError, FieldDoesNotExist):\n                    pass\n            for kwarg in kwargs:\n>               raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\nE               TypeError: ActivityLogs() got an unexpected keyword argument 'time_stamp'\n\n..\\..\\..\\mmtxt\\lib\\site-packages\\django\\db\\models\\base.py:503: TypeError\n", "test_name": "test_activitylogs[testuser8@kpmg.com-False-False]", "rerun": "0"}}, "suite_name": "usermanagement/Test_usermanagement/test_models.py"}}}, "date": "August 18, 2021", "start_time": 1629277744.3682394, "total_suite": 1, "status": "FAIL", "status_list": {"pass": "0", "fail": "0", "skip": "0", "error": "8", "xpass": "0", "xfail": "0", "rerun": "0"}, "total_tests": "8"}